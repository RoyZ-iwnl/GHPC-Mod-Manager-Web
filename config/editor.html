<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GHPC Mod Config ç¼–è¾‘å™¨</title>
  <style>
    /* ===== å…¨å±€æ ·å¼ ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
      background: #0f1117;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ===== é¡¶éƒ¨æ ‡é¢˜æ  ===== */
    header {
      background: #1a1d2e;
      border-bottom: 1px solid #2e3250;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
    }

    header h1 {
      font-size: 18px;
      color: #7eb8f7;
    }

    header span {
      font-size: 12px;
      color: #666;
    }

    .header-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
    }

    /* ===== æŒ‰é’®é€šç”¨ ===== */
    button {
      border: none;
      border-radius: 6px;
      padding: 7px 14px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s;
    }

    .btn-primary {
      background: #3b82f6;
      color: #fff;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    .btn-success {
      background: #22c55e;
      color: #fff;
    }

    .btn-success:hover {
      background: #16a34a;
    }

    .btn-danger {
      background: #ef4444;
      color: #fff;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .btn-ghost {
      background: transparent;
      border: 1px solid #3e4263;
      color: #aaa;
    }

    .btn-ghost:hover {
      background: #2a2d42;
      color: #fff;
    }

    /* ===== ä¸»ä½“å¸ƒå±€ï¼šå·¦å³åˆ†æ  ===== */
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ===== å·¦ä¾§ç¼–è¾‘åŒº ===== */
    .editor-panel {
      width: 55%;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #2e3250;
      overflow: hidden;
    }

    .panel-header {
      background: #141624;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid #2e3250;
      flex-shrink: 0;
    }

    .panel-header h2 {
      font-size: 14px;
      color: #aaa;
      font-weight: 500;
    }

    .mod-count {
      background: #3b82f6;
      color: #fff;
      border-radius: 12px;
      padding: 2px 8px;
      font-size: 12px;
    }

    .mod-list {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
      min-height: 0;
    }

    .mod-list>* {
      margin-bottom: 10px;
    }

    .mod-list>*:last-child {
      margin-bottom: 0;
    }

    /* ===== Mod å¡ç‰‡ ===== */
    .mod-card {
      background: #1a1d2e;
      border: 1px solid #2e3250;
      border-radius: 10px;
      overflow: hidden;
      transition: border-color 0.2s;
    }

    .mod-card:hover {
      border-color: #4e5580;
    }

    .mod-card.active {
      border-color: #3b82f6;
    }

    .drag-handle {
      cursor: grab;
      color: #555;
      font-size: 16px;
      padding-right: 8px;
      flex-shrink: 0;
      line-height: 1;
    }
    .drag-handle:active { cursor: grabbing; }
    .mod-card.drag-over { border-color: #3b82f6; opacity: 0.6; }

    .card-header {
      display: flex;
      align-items: center;
      padding: 10px 14px;
      cursor: pointer;
      background: #1e2236;
      user-select: none;
    }

    .card-header:hover {
      background: #242840;
    }

    .card-index {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: #3b82f6;
      color: #fff;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-right: 10px;
    }

    .card-title {
      flex: 1;
      font-size: 14px;
      font-weight: 500;
    }

    .card-subtitle {
      font-size: 11px;
      color: #666;
      margin-top: 2px;
    }

    .card-toggle {
      font-size: 18px;
      color: #555;
      transition: transform 0.2s;
    }

    .card-toggle.open {
      transform: rotate(90deg);
    }

    .card-body {
      display: none;
      padding: 14px;
      border-top: 1px solid #2e3250;
    }

    .card-body.open {
      display: block;
    }

    /* ===== è¡¨å•å­—æ®µ ===== */
    .form-row {
      margin-bottom: 12px;
    }

    .form-row label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }

    .form-row label span.required {
      color: #f87171;
      margin-left: 2px;
    }

    .form-row input,
    .form-row select,
    .form-row textarea {
      width: 100%;
      background: #0f1117;
      border: 1px solid #2e3250;
      border-radius: 6px;
      color: #e0e0e0;
      padding: 7px 10px;
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }

    .form-row input:focus,
    .form-row select:focus,
    .form-row textarea:focus {
      border-color: #3b82f6;
    }

    .form-row select option {
      background: #1a1d2e;
    }

    /* åŒåˆ—å¸ƒå±€ */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    /* Name å›½é™…åŒ– */
    .i18n-group {
      border: 1px solid #2e3250;
      border-radius: 6px;
      padding: 10px;
      background: #12141f;
    }

    .i18n-group .form-row {
      margin-bottom: 8px;
    }

    .i18n-group .form-row:last-child {
      margin-bottom: 0;
    }

    /* æ•°ç»„æ ‡ç­¾è¾“å…¥ï¼ˆRequirements / Conflictsï¼‰ */
    .tag-input-wrapper {
      background: #0f1117;
      border: 1px solid #2e3250;
      border-radius: 6px;
      padding: 6px 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      cursor: text;
      min-height: 38px;
      transition: border-color 0.2s;
    }

    .tag-input-wrapper:focus-within {
      border-color: #3b82f6;
    }

    .tag {
      background: #2e3a5c;
      color: #93c5fd;
      border-radius: 4px;
      padding: 2px 8px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tag-remove {
      cursor: pointer;
      color: #9ca3af;
      font-size: 14px;
      line-height: 1;
    }

    .tag-remove:hover {
      color: #f87171;
    }

    .tag-input {
      border: none;
      background: transparent;
      color: #e0e0e0;
      font-size: 13px;
      outline: none;
      flex: 1;
      min-width: 80px;
    }

    /* è‡ªåŠ¨è¡¥å…¨å€™é€‰æ¡† */
    .autocomplete-dropdown {
      position: absolute;
      background: #1a1d2e;
      border: 1px solid #3b82f6;
      border-radius: 6px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .autocomplete-item {
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
      color: #e0e0e0;
    }

    .autocomplete-item:hover {
      background: #2a2d42;
    }

    /* å¡ç‰‡åº•éƒ¨æ“ä½œ */
    .card-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px solid #2e3250;
      gap: 8px;
    }

    /* ===== å³ä¾§é¢„è§ˆåŒº ===== */
    .preview-panel {
      width: 45%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .preview-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    pre#json-preview {
      flex: 1;
      overflow: auto;
      padding: 16px;
      font-family: 'Cascadia Code', 'Consolas', monospace;
      font-size: 12.5px;
      line-height: 1.7;
      background: #0a0c14;
      color: #cdd6f4;
      white-space: pre;
      margin: 0;
    }

    /* JSON è¯­æ³•é«˜äº® */
    .json-key {
      color: #89b4fa;
    }

    .json-string {
      color: #a6e3a1;
    }

    .json-number {
      color: #fab387;
    }

    .json-bool {
      color: #f38ba8;
    }

    .json-null {
      color: #a6adc8;
    }

    .json-punct {
      color: #cdd6f4;
    }

    /* ===== ç©ºçŠ¶æ€ ===== */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: #555;
      gap: 12px;
    }

    .empty-state svg {
      opacity: 0.4;
    }

    /* ===== æç¤ºæ¡ ===== */
    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: #22c55e;
      color: #fff;
      padding: 10px 18px;
      border-radius: 8px;
      font-size: 13px;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s;
      z-index: 999;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* æ»šåŠ¨æ¡ç¾åŒ– */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #2e3250;
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4e5580;
    }
  </style>
</head>

<body>

  <!-- é¡¶éƒ¨æ ‡é¢˜æ  -->
  <header>
    <h1 id="header-title">âš™ï¸ GHPC Mod Config ç¼–è¾‘å™¨</h1>
    <span id="header-subtitle">modconfig.jsonc å¯è§†åŒ–ç¼–è¾‘å·¥å…·</span>
    <div class="header-actions">
      <button class="btn-ghost" onclick="switchLang()" id="lang-btn">ğŸŒ EN</button>
      <button class="btn-ghost" onclick="importJSON()" id="import-btn">ğŸ“‚ å¯¼å…¥ JSON</button>
      <button class="btn-ghost" onclick="loadSample()" id="sample-btn">ğŸ“‹ åŠ è½½ç¤ºä¾‹</button>
      <button class="btn-ghost" onclick="checkConflicts()" id="check-btn">ğŸ” æ£€æŸ¥å†²çª</button>
      <button class="btn-primary" onclick="addMod()" id="add-btn">ï¼‹ æ–°å¢ Mod</button>
      <input type="file" id="file-input" accept=".json,.jsonc" style="display:none"
        onchange="handleFileImport(event)" />
    </div>
  </header>

  <div class="main">
    <!-- å·¦ä¾§ç¼–è¾‘åŒº -->
    <div class="editor-panel">
      <div class="panel-header">
        <h2 id="panel-mod-list">Mod åˆ—è¡¨</h2>
        <span class="mod-count" id="mod-count">0</span>
      </div>
      <div class="mod-list" id="mod-list">
        <div class="empty-state">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="3" width="18" height="18" rx="2" />
            <path d="M3 9h18M9 21V9" />
          </svg>
          <span>æš‚æ—  Modï¼Œç‚¹å‡»å³ä¸Šè§’ã€Œæ–°å¢ Modã€å¼€å§‹</span>
        </div>
      </div>
    </div>

    <!-- å³ä¾§é¢„è§ˆåŒº -->
    <div class="preview-panel">
      <div class="panel-header">
        <h2 id="panel-json-preview">JSON é¢„è§ˆ</h2>
        <div class="preview-actions">
          <button class="btn-ghost" onclick="copyJSON()" id="copy-btn">ğŸ“‹ å¤åˆ¶</button>
          <button class="btn-success" onclick="downloadJSON()" id="export-btn">ğŸ’¾ å¯¼å‡º</button>
        </div>
      </div>
      <pre id="json-preview">[]</pre>
    </div>
  </div>

  <!-- æç¤ºæ¡ -->
  <div class="toast" id="toast"></div>

  <script>
    // ===== å¤šè¯­è¨€ç¿»è¯‘ =====
    const translations = {
      'zh-CN': {
        title: 'GHPC Mod Config ç¼–è¾‘å™¨',
        subtitle: 'modconfig.jsonc å¯è§†åŒ–ç¼–è¾‘å·¥å…·',
        importBtn: 'ğŸ“‚ å¯¼å…¥ JSON',
        loadSampleBtn: 'ğŸ“‹ åŠ è½½ç¤ºä¾‹',
        checkConflictsBtn: 'ğŸ” æ£€æŸ¥å†²çª',
        addModBtn: 'ï¼‹ æ–°å¢ Mod',
        modList: 'Mod åˆ—è¡¨',
        jsonPreview: 'JSON é¢„è§ˆ',
        copyBtn: 'ğŸ“‹ å¤åˆ¶',
        exportBtn: 'ğŸ’¾ å¯¼å‡º',
        emptyState: 'æš‚æ—  Modï¼Œç‚¹å‡»å³ä¸Šè§’ã€Œæ–°å¢ Modã€å¼€å§‹',
        modId: 'Mod ID',
        required: '*',
        installMethod: 'å®‰è£…æ–¹å¼',
        directRelease: 'DirectReleaseï¼ˆç›´æ¥è§£å‹ï¼‰',
        scripted: 'Scriptedï¼ˆè„šæœ¬å®‰è£…ï¼‰',
        modName: 'Mod åç§°ï¼ˆå¤šè¯­è¨€ï¼‰',
        releaseUrl: 'GitHub Release URL',
        targetFileKeyword: 'ç›®æ ‡æ–‡ä»¶å…³é”®è¯',
        mainBinaryFile: 'ä¸» DLL æ–‡ä»¶å',
        configSection: 'é…ç½®èŠ‚åç§°ï¼ˆConfigSectionNameï¼‰',
        installScript: 'å®‰è£…è„šæœ¬ï¼ˆInstallScript_Base64ï¼‰',
        editSource: 'ğŸ“ ç¼–è¾‘æºç ',
        saveBase64: 'ğŸ’¾ ä¿å­˜ä¸º Base64',
        requirements: 'ä¾èµ–ï¼ˆRequirementsï¼‰â€” è¾“å…¥åæŒ‰ Enter æ·»åŠ ',
        conflicts: 'å†²çªï¼ˆConflictsï¼‰â€” è¾“å…¥åæŒ‰ Enter æ·»åŠ ',
        inputPlaceholder: 'è¾“å…¥ ModId åæŒ‰ Enter',
        deleteMod: 'ğŸ—‘ åˆ é™¤æ­¤ Mod',
        deleteConfirm: 'ç¡®å®šåˆ é™¤ç¬¬ {0} ä¸ª Modï¼ˆ{1}ï¼‰ï¼Ÿ',
        unnamed: 'æœªå‘½å',
        description: 'Mod æè¿°ï¼ˆå¤šè¯­è¨€ï¼‰',
        tags: 'æ ‡ç­¾ï¼ˆTagsï¼‰â€” æ ¼å¼ï¼škey=ä¸­æ–‡/è‹±æ–‡ï¼ŒæŒ‰ Enter æ·»åŠ ',
        tagsPlaceholder: 'å¦‚ï¼šbalance=å¹³è¡¡/Balance',
        supportedVersions: 'æ”¯æŒçš„æ¸¸æˆç‰ˆæœ¬ï¼ˆSupportedGameVersionsï¼‰â€” è¾“å…¥åæŒ‰ Enter æ·»åŠ ',
        versionsPlaceholder: 'å¦‚ï¼š20260210'
      },
      'en-US': {
        title: 'GHPC Mod Config Editor',
        subtitle: 'Visual editor for modconfig.jsonc',
        importBtn: 'ğŸ“‚ Import JSON',
        loadSampleBtn: 'ğŸ“‹ Load Sample',
        checkConflictsBtn: 'ğŸ” Check Conflicts',
        addModBtn: 'ï¼‹ Add Mod',
        modList: 'Mod List',
        jsonPreview: 'JSON Preview',
        copyBtn: 'ğŸ“‹ Copy',
        exportBtn: 'ğŸ’¾ Export',
        emptyState: 'No mods yet, click "Add Mod" to start',
        modId: 'Mod ID',
        required: '*',
        installMethod: 'Install Method',
        directRelease: 'DirectRelease (Extract directly)',
        scripted: 'Scripted (Script installation)',
        modName: 'Mod Name (Multilingual)',
        releaseUrl: 'GitHub Release URL',
        targetFileKeyword: 'Target File Keyword',
        mainBinaryFile: 'Main DLL Filename',
        configSection: 'Config Section Name',
        installScript: 'Install Script (Base64)',
        editSource: 'ğŸ“ Edit Source',
        saveBase64: 'ğŸ’¾ Save as Base64',
        requirements: 'Requirements â€” Press Enter to add',
        conflicts: 'Conflicts â€” Press Enter to add',
        inputPlaceholder: 'Enter ModId and press Enter',
        deleteMod: 'ğŸ—‘ Delete Mod',
        deleteConfirm: 'Delete Mod #{0} ({1})?',
        unnamed: 'Unnamed',
        description: 'Mod Description (Multilingual)',
        tags: 'Tags â€” Format: key=Chinese/English, press Enter to add',
        tagsPlaceholder: 'e.g.: balance=å¹³è¡¡/Balance',
        supportedVersions: 'Supported Game Versions â€” Press Enter to add',
        versionsPlaceholder: 'e.g.: 20260210'
      }
    };

    let currentLang = localStorage.getItem('lang') || 'zh-CN';
    const t = (key) => translations[currentLang][key] || key;

    // ===== å…¨å±€æ•°æ® =====
    let mods = [];

    // ===== åˆå§‹åŒ– =====
    function init() {
      applyTranslations();
      renderAll();
    }

    // ===== è¯­è¨€åˆ‡æ¢ =====
    function switchLang() {
      currentLang = currentLang === 'zh-CN' ? 'en-US' : 'zh-CN';
      localStorage.setItem('lang', currentLang);
      applyTranslations();
      renderAll();
    }

    function applyTranslations() {
      document.getElementById('header-title').textContent = 'âš™ï¸ ' + t('title');
      document.getElementById('header-subtitle').textContent = t('subtitle');
      document.getElementById('lang-btn').textContent = currentLang === 'zh-CN' ? 'ğŸŒ EN' : 'ğŸŒ ä¸­æ–‡';
      document.getElementById('import-btn').textContent = t('importBtn');
      document.getElementById('sample-btn').textContent = t('loadSampleBtn');
      document.getElementById('check-btn').textContent = t('checkConflictsBtn');
      document.getElementById('add-btn').textContent = t('addModBtn');
      document.getElementById('panel-mod-list').textContent = t('modList');
      document.getElementById('panel-json-preview').textContent = t('jsonPreview');
      document.getElementById('copy-btn').textContent = t('copyBtn');
      document.getElementById('export-btn').textContent = t('exportBtn');
    }

    // ===== æ–°å¢ Mod =====
    function addMod() {
      mods.push({
        Id: '',
        Name: { 'en-US': '', 'zh-CN': '' },
        Description: { 'en-US': '', 'zh-CN': '' },
        Tags: {},
        SupportedGameVersions: [],
        ReleaseUrl: '',
        TargetFileNameKeyword: '.zip',
        MainBinaryFileName: '',
        ConfigSectionName: '',
        InstallMethod: 'DirectRelease',
        InstallScript_Base64: '',
        Requirements: [],
        Conflicts: []
      });
      renderAll();
      // è‡ªåŠ¨å±•å¼€æœ€åä¸€ä¸ª
      setTimeout(() => toggleCard(mods.length - 1), 50);
    }

    // ===== åˆ é™¤ Mod =====
    function deleteMod(index) {
      const modName = mods[index].Id || t('unnamed');
      const msg = t('deleteConfirm').replace('{0}', index + 1).replace('{1}', modName);
      if (!confirm(msg)) return;
      mods.splice(index, 1);
      renderAll();
    }

    // ===== æ‹–æ‹½æ’åº =====
    let dragSrcIdx = null;
    function onDragStart(e, i) { dragSrcIdx = i; e.dataTransfer.effectAllowed = 'move'; }
    function onDragOver(e, i) {
      e.preventDefault();
      document.querySelectorAll('.mod-card').forEach(c => c.classList.remove('drag-over'));
      document.getElementById('card-' + i).classList.add('drag-over');
    }
    function onDrop(e, i) {
      e.preventDefault();
      if (dragSrcIdx === null || dragSrcIdx === i) return;
      mods.splice(i, 0, mods.splice(dragSrcIdx, 1)[0]);
      dragSrcIdx = null;
      renderAll();
    }
    function onDragEnd() {
      document.querySelectorAll('.mod-card').forEach(c => c.classList.remove('drag-over'));
      dragSrcIdx = null;
    }

    // ===== å±•å¼€/æŠ˜å å¡ç‰‡ =====
    function toggleCard(index) {
      const body = document.getElementById(`card-body-${index}`);
      const toggle = document.getElementById(`card-toggle-${index}`);
      if (!body) return;
      const isOpen = body.classList.toggle('open');
      toggle.classList.toggle('open', isOpen);
      document.getElementById(`card-${index}`)?.classList.toggle('active', isOpen);

      // åŒæ­¥æ»šåŠ¨åˆ°å¯¹åº”çš„ JSON ä½ç½®
      if (isOpen) {
        setTimeout(() => {
          const anchor = document.getElementById(`json-mod-${index}`);
          if (anchor) {
            const preview = document.getElementById('json-preview');
            const offsetTop = anchor.offsetTop - preview.offsetTop;
            preview.scrollTo({ top: offsetTop - 20, behavior: 'smooth' });
          }
        }, 100);
      }
    }

    // ===== å­—æ®µæ›´æ–° =====
    function updateField(index, field, value) {
      if (field === 'Name.en-US') {
        mods[index].Name['en-US'] = value;
      } else if (field === 'Name.zh-CN') {
        mods[index].Name['zh-CN'] = value;
      } else if (field === 'Description.en-US') {
        mods[index].Description['en-US'] = value;
      } else if (field === 'Description.zh-CN') {
        mods[index].Description['zh-CN'] = value;
      } else {
        mods[index][field] = value;
      }

      // åˆ‡æ¢ InstallMethod æ—¶æ˜¾ç¤º/éšè—è„šæœ¬åŒºåŸŸ
      if (field === 'InstallMethod') {
        const scriptArea = document.getElementById(`script-area-${index}`);
        if (scriptArea) scriptArea.style.display = value === 'Scripted' ? 'block' : 'none';
      }

      updatePreview();
      // æ›´æ–°å¡ç‰‡æ ‡é¢˜
      const titleEl = document.getElementById(`card-title-${index}`);
      const subtitleEl = document.getElementById(`card-subtitle-${index}`);
      if (titleEl) titleEl.textContent = mods[index].Id || `Mod #${index + 1}`;
      if (subtitleEl) subtitleEl.textContent = mods[index].Name['en-US'] || '';
    }

    // ===== æ ‡ç­¾è¾“å…¥ï¼ˆRequirements / Conflicts / SupportedGameVersions / Tagsï¼‰ =====
    function renderTags(index, field) {
      const wrapper = document.getElementById(`tags-${index}-${field}`);
      if (!wrapper) return;
      wrapper.querySelectorAll('.tag').forEach(t => t.remove());
      const input = wrapper.querySelector('.tag-input');

      if (field === 'Tags') {
        const tags = mods[index].Tags || {};
        Object.entries(tags).forEach(([key, val]) => {
          const label = `${key}=${val['zh-CN'] || ''}/${val['en-US'] || ''}`;
          const el = document.createElement('div');
          el.className = 'tag';
          el.innerHTML = `${esc(label)}<span class="tag-remove" onclick="removeTagKey(${index},'${key}')">Ã—</span>`;
          wrapper.insertBefore(el, input);
        });
      } else {
        const tags = mods[index][field] || [];
        tags.forEach((tag, ti) => {
          const el = document.createElement('div');
          el.className = 'tag';
          el.innerHTML = `${esc(tag)}<span class="tag-remove" onclick="removeTag(${index},'${field}',${ti})">Ã—</span>`;
          wrapper.insertBefore(el, input);
        });
      }
    }

    function addTag(index, field, value) {
      const val = value.trim();
      if (!val) return;

      if (field === 'Tags') {
        // æ ¼å¼ï¼škey=ä¸­æ–‡/è‹±æ–‡  æˆ–  key=è‹±æ–‡ï¼ˆæ— ä¸­æ–‡ï¼‰
        const eqIdx = val.indexOf('=');
        if (eqIdx < 1) return;
        const key = val.slice(0, eqIdx).trim();
        const rest = val.slice(eqIdx + 1).trim();
        const slashIdx = rest.indexOf('/');
        let zhCN, enUS;
        if (slashIdx >= 0) {
          zhCN = rest.slice(0, slashIdx).trim();
          enUS = rest.slice(slashIdx + 1).trim();
        } else {
          zhCN = rest;
          enUS = rest;
        }
        if (!key) return;
        if (!mods[index].Tags) mods[index].Tags = {};
        mods[index].Tags[key] = { 'zh-CN': zhCN, 'en-US': enUS };
      } else {
        if (!Array.isArray(mods[index][field])) mods[index][field] = [];
        if (!mods[index][field].includes(val)) {
          mods[index][field].push(val);
        }
      }
      renderTags(index, field);
      updatePreview();
    }

    function removeTag(index, field, ti) {
      mods[index][field].splice(ti, 1);
      renderTags(index, field);
      updatePreview();
    }

    function removeTagKey(index, key) {
      if (mods[index].Tags) {
        delete mods[index].Tags[key];
        renderTags(index, 'Tags');
        updatePreview();
      }
    }

    function handleTagKeydown(e, index, field) {
      if (e.key === 'Enter' || e.key === ',') {
        e.preventDefault();
        addTag(index, field, e.target.value);
        e.target.value = '';
        hideAutocomplete();
      } else if (e.key === 'Backspace' && e.target.value === '') {
        if (mods[index][field].length > 0) {
          mods[index][field].pop();
          renderTags(index, field);
          updatePreview();
        }
      } else if (e.key === 'Escape') {
        hideAutocomplete();
      }
    }

    // è‡ªåŠ¨è¡¥å…¨åŠŸèƒ½
    let currentAutocomplete = null;
    let isSelectingFromDropdown = false;

    function showAutocomplete(input, index, field) {
      const value = input.value.trim().toLowerCase();
      if (!value) {
        hideAutocomplete();
        return;
      }

      const availableIds = mods
        .map(m => m.Id)
        .filter(id => id && id.toLowerCase().includes(value) && !mods[index][field].includes(id) && id !== mods[index].Id);

      if (availableIds.length === 0) {
        hideAutocomplete();
        return;
      }

      hideAutocomplete();

      const dropdown = document.createElement('div');
      dropdown.className = 'autocomplete-dropdown';
      dropdown.id = 'autocomplete-dropdown';

      const rect = input.getBoundingClientRect();
      dropdown.style.position = 'fixed';
      dropdown.style.left = rect.left + 'px';
      dropdown.style.top = rect.bottom + 2 + 'px';
      dropdown.style.minWidth = rect.width + 'px';

      availableIds.forEach(id => {
        const item = document.createElement('div');
        item.className = 'autocomplete-item';
        item.textContent = id;
        item.onmousedown = (e) => {
          e.preventDefault();
          isSelectingFromDropdown = true;
          addTag(index, field, id);
          input.value = '';
          hideAutocomplete();
          input.focus();
          setTimeout(() => isSelectingFromDropdown = false, 100);
        };
        dropdown.appendChild(item);
      });

      document.body.appendChild(dropdown);
      currentAutocomplete = dropdown;
    }

    function hideAutocomplete() {
      if (currentAutocomplete) {
        currentAutocomplete.remove();
        currentAutocomplete = null;
      }
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tag-input-wrapper') && !e.target.closest('.autocomplete-dropdown')) {
        hideAutocomplete();
      }
    });

    // ===== æ¸²æŸ“ Mod å¡ç‰‡åˆ—è¡¨ =====
    function renderAll() {
      const list = document.getElementById('mod-list');
      document.getElementById('mod-count').textContent = mods.length;

      if (mods.length === 0) {
        list.innerHTML = `<div class="empty-state">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/>
        </svg>
        <span>${t('emptyState')}</span>
      </div>`;
        updatePreview();
        return;
      }

      list.innerHTML = mods.map((mod, i) => `
      <div class="mod-card" id="card-${i}" ondragstart="onDragStart(event,${i})" ondragover="onDragOver(event,${i})" ondrop="onDrop(event,${i})" ondragend="onDragEnd()">
        <div class="card-header" onclick="toggleCard(${i})">
          <span class="drag-handle" onclick="event.stopPropagation()" onmousedown="this.closest('.mod-card').draggable=true" onmouseup="this.closest('.mod-card').draggable=false">â ¿</span>
          <div class="card-index">${i + 1}</div>
          <div style="flex:1">
            <div class="card-title" id="card-title-${i}">${mod.Id || `Mod #${i + 1}`}</div>
            <div class="card-subtitle" id="card-subtitle-${i}">${mod.Name['en-US'] || ''}</div>
          </div>
          <span class="card-toggle" id="card-toggle-${i}">â€º</span>
        </div>
        <div class="card-body" id="card-body-${i}">
          <!-- åŸºæœ¬ä¿¡æ¯ -->
          <div class="form-grid">
            <div class="form-row">
              <label>Mod ID <span class="required">*</span></label>
              <input type="text" value="${esc(mod.Id)}" placeholder="å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œæ— ç©ºæ ¼"
                oninput="updateField(${i},'Id',this.value)" />
            </div>
            <div class="form-row">
              <label>å®‰è£…æ–¹å¼</label>
              <select onchange="updateField(${i},'InstallMethod',this.value)">
                <option value="DirectRelease" ${mod.InstallMethod === 'DirectRelease' ? 'selected' : ''}>DirectReleaseï¼ˆç›´æ¥è§£å‹ï¼‰</option>
                <option value="Scripted" ${mod.InstallMethod === 'Scripted' ? 'selected' : ''}>Scriptedï¼ˆè„šæœ¬å®‰è£…ï¼‰</option>
              </select>
            </div>
          </div>

          <!-- å¤šè¯­è¨€åç§° -->
          <div class="form-row">
            <label>Mod åç§°ï¼ˆå¤šè¯­è¨€ï¼‰</label>
            <div class="i18n-group">
              <div class="form-row">
                <label>ğŸ‡ºğŸ‡¸ en-US</label>
                <input type="text" value="${esc(mod.Name['en-US'])}" placeholder="English name"
                  oninput="updateField(${i},'Name.en-US',this.value)" />
              </div>
              <div class="form-row">
                <label>ğŸ‡¨ğŸ‡³ zh-CN</label>
                <input type="text" value="${esc(mod.Name['zh-CN'])}" placeholder="ä¸­æ–‡åç§°"
                  oninput="updateField(${i},'Name.zh-CN',this.value)" />
              </div>
            </div>
          </div>

          <!-- å¤šè¯­è¨€æè¿° -->
          <div class="form-row">
            <label>${t('description')}</label>
            <div class="i18n-group">
              <div class="form-row">
                <label>ğŸ‡ºğŸ‡¸ en-US</label>
                <textarea rows="2" style="width:100%;background:#0f1117;border:1px solid #2e3250;border-radius:6px;color:#e0e0e0;padding:8px;font-size:13px;resize:vertical"
                  oninput="updateField(${i},'Description.en-US',this.value)">${esc(mod.Description?.['en-US'] || '')}</textarea>
              </div>
              <div class="form-row">
                <label>ğŸ‡¨ğŸ‡³ zh-CN</label>
                <textarea rows="2" style="width:100%;background:#0f1117;border:1px solid #2e3250;border-radius:6px;color:#e0e0e0;padding:8px;font-size:13px;resize:vertical"
                  oninput="updateField(${i},'Description.zh-CN',this.value)">${esc(mod.Description?.['zh-CN'] || '')}</textarea>
              </div>
            </div>
          </div>

          <!-- Tags -->
          <div class="form-row">
            <label>${t('tags')}</label>
            <div class="tag-input-wrapper" id="tags-${i}-Tags"
              onclick="this.querySelector('.tag-input').focus()">
              <input class="tag-input" type="text" placeholder="${t('tagsPlaceholder')}"
                onkeydown="handleTagKeydown(event,${i},'Tags')" />
            </div>
          </div>

          <!-- SupportedGameVersions -->
          <div class="form-row">
            <label>${t('supportedVersions')}</label>
            <div class="tag-input-wrapper" id="tags-${i}-SupportedGameVersions"
              onclick="this.querySelector('.tag-input').focus()">
              <input class="tag-input" type="text" placeholder="${t('versionsPlaceholder')}"
                onkeydown="handleTagKeydown(event,${i},'SupportedGameVersions')" />
            </div>
          </div>

          <!-- GitHub Release URL -->
          <div class="form-row">
            <label>GitHub Release URL <span class="required">*</span></label>
            <input type="text" value="${esc(mod.ReleaseUrl)}"
              placeholder="https://api.github.com/repos/owner/repo/releases/latest"
              oninput="updateField(${i},'ReleaseUrl',this.value)" />
          </div>

          <div class="form-grid">
            <div class="form-row">
              <label>ç›®æ ‡æ–‡ä»¶å…³é”®è¯</label>
              <input type="text" value="${esc(mod.TargetFileNameKeyword)}" placeholder=".zip"
                oninput="updateField(${i},'TargetFileNameKeyword',this.value)" />
            </div>
            <div class="form-row">
              <label>ä¸» DLL æ–‡ä»¶å</label>
              <input type="text" value="${esc(mod.MainBinaryFileName)}" placeholder="YourMod.dll"
                oninput="updateField(${i},'MainBinaryFileName',this.value)" />
            </div>
          </div>

          <div class="form-row">
            <label>é…ç½®èŠ‚åç§°ï¼ˆConfigSectionNameï¼‰</label>
            <input type="text" value="${esc(mod.ConfigSectionName)}" placeholder="YourModConfig"
              oninput="updateField(${i},'ConfigSectionName',this.value)" />
          </div>

          <!-- è„šæœ¬ç¼–è¾‘åŒºï¼ˆä»… Scripted æ¨¡å¼ï¼‰ -->
          <div class="form-row" id="script-area-${i}" style="display:${mod.InstallMethod === 'Scripted' ? 'block' : 'none'}">
            <label>å®‰è£…è„šæœ¬ï¼ˆInstallScript_Base64ï¼‰<button type="button" class="btn-ghost" style="margin-left:8px;padding:4px 8px;font-size:12px" id="script-btn-${i}" data-mode="base64" onclick="toggleScriptMode(${i})">ğŸ“ ç¼–è¾‘æºç </button></label>
            <textarea id="script-${i}" rows="6" style="width:100%;background:#0f1117;border:1px solid #2e3250;border-radius:6px;color:#e0e0e0;padding:8px;font-family:monospace;font-size:12px;resize:vertical" oninput="mods[${i}].InstallScript_Base64=this.value;updatePreview()">${esc(mod.InstallScript_Base64)}</textarea>
          </div>

          <!-- ä¾èµ– -->
          <div class="form-row">
            <label>ä¾èµ–ï¼ˆRequirementsï¼‰â€” è¾“å…¥åæŒ‰ Enter æ·»åŠ </label>
            <div class="tag-input-wrapper" id="tags-${i}-Requirements"
              onclick="this.querySelector('.tag-input').focus()">
              <input class="tag-input" type="text" placeholder="è¾“å…¥ ModId åæŒ‰ Enter"
                oninput="showAutocomplete(this,${i},'Requirements')"
                onkeydown="handleTagKeydown(event,${i},'Requirements')"
                onblur="setTimeout(()=>{if(!isSelectingFromDropdown&&this.value){addTag(${i},'Requirements',this.value);this.value=''}hideAutocomplete()},100)" />
            </div>
          </div>

          <!-- å†²çª -->
          <div class="form-row">
            <label>å†²çªï¼ˆConflictsï¼‰â€” è¾“å…¥åæŒ‰ Enter æ·»åŠ </label>
            <div class="tag-input-wrapper" id="tags-${i}-Conflicts"
              onclick="this.querySelector('.tag-input').focus()">
              <input class="tag-input" type="text" placeholder="è¾“å…¥ ModId åæŒ‰ Enter"
                oninput="showAutocomplete(this,${i},'Conflicts')"
                onkeydown="handleTagKeydown(event,${i},'Conflicts')"
                onblur="setTimeout(()=>{if(!isSelectingFromDropdown&&this.value){addTag(${i},'Conflicts',this.value);this.value=''}hideAutocomplete()},100)" />
            </div>
          </div>

          <!-- æ“ä½œæŒ‰é’® -->
          <div class="card-actions">
            <button class="btn-danger" onclick="deleteMod(${i})">ğŸ—‘ åˆ é™¤æ­¤ Mod</button>
          </div>
        </div>
      </div>
    `).join('');

      // æ¸²æŸ“æ ‡ç­¾
      mods.forEach((mod, i) => {
        renderTags(i, 'Requirements');
        renderTags(i, 'Conflicts');
        renderTags(i, 'Tags');
        renderTags(i, 'SupportedGameVersions');
      });

      updatePreview();
    }

    // ===== æ„å»ºè¾“å‡ºå¯¹è±¡ =====
    function buildModObj(mod) {
      const obj = { Id: mod.Id, Name: mod.Name };
      if (mod.Description?.['en-US'] || mod.Description?.['zh-CN']) obj.Description = mod.Description;
      if (mod.Tags && Object.keys(mod.Tags).length > 0) obj.Tags = mod.Tags;
      if (mod.SupportedGameVersions?.length > 0) obj.SupportedGameVersions = mod.SupportedGameVersions;
      if (mod.ReleaseUrl) obj.ReleaseUrl = mod.ReleaseUrl;
      if (mod.TargetFileNameKeyword) obj.TargetFileNameKeyword = mod.TargetFileNameKeyword;
      if (mod.MainBinaryFileName) obj.MainBinaryFileName = mod.MainBinaryFileName;
      if (mod.ConfigSectionName) obj.ConfigSectionName = mod.ConfigSectionName;
      obj.InstallMethod = mod.InstallMethod;
      if (mod.InstallMethod === 'Scripted' && mod.InstallScript_Base64) obj.InstallScript_Base64 = mod.InstallScript_Base64;
      if (mod.Requirements?.length > 0) obj.Requirements = mod.Requirements;
      if (mod.Conflicts?.length > 0) obj.Conflicts = mod.Conflicts;
      return obj;
    }

    // ===== JSON é¢„è§ˆ =====
    function updatePreview() {
      const output = mods.map(mod => {
        return buildModObj(mod);
      });
      const raw = JSON.stringify(output, null, 2);

      // ä¸ºæ¯ä¸ª Mod æ·»åŠ é”šç‚¹æ ‡è®°
      let html = syntaxHighlight(raw);
      const lines = html.split('\n');
      let modIndex = 0;
      const result = lines.map((line, i) => {
        if (line.trim().startsWith('{') && modIndex < mods.length && i > 0) {
          return `<span id="json-mod-${modIndex++}" class="json-anchor"></span>${line}`;
        }
        return line;
      }).join('\n');

      document.getElementById('json-preview').innerHTML = result;
    }

    // ===== JSON è¯­æ³•é«˜äº® =====
    function syntaxHighlight(json) {
      return json
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/("(\\u[\da-fA-F]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+\.?\d*(?:[eE][+\-]?\d+)?)/g, match => {
          let cls = 'json-number';
          if (/^"/.test(match)) {
            cls = /:$/.test(match) ? 'json-key' : 'json-string';
          } else if (/true|false/.test(match)) {
            cls = 'json-bool';
          } else if (/null/.test(match)) {
            cls = 'json-null';
          }
          return `<span class="${cls}">${match}</span>`;
        });
    }

    // ===== å¤åˆ¶ JSON =====
    function copyJSON() {
      const output = mods.map(buildModObj);
      navigator.clipboard.writeText(JSON.stringify(output, null, 2)).then(() => showToast('âœ… JSON å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'));
    }

    // ===== å¯¼å‡º JSON =====
    function downloadJSON() {
      const output = mods.map(buildModObj);
      const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'modconfig.json';
      a.click();
      showToast('ğŸ’¾ æ–‡ä»¶å·²å¯¼å‡º');
    }

    // ===== å¯¼å…¥ JSON =====
    function importJSON() {
      document.getElementById('file-input').click();
    }

    function handleFileImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const text = e.target.result;
          // ä½¿ç”¨å®‰å…¨çš„ JSONC -> JSON è½¬æ¢ï¼ˆä¸ä¼šè¯¯åˆ å­—ç¬¦ä¸²é‡Œçš„å†…å®¹ï¼‰
          const cleaned = stripJsonCommentsSafe(text);
          const parsed = JSON.parse(cleaned);
          if (!Array.isArray(parsed)) throw new Error('é¡¶å±‚å¿…é¡»æ˜¯æ•°ç»„');
          mods = parsed.map(m => ({
            Id: m.Id || '',
            Name: { 'en-US': m.Name?.['en-US'] || '', 'zh-CN': m.Name?.['zh-CN'] || '' },
            Description: { 'en-US': m.Description?.['en-US'] || '', 'zh-CN': m.Description?.['zh-CN'] || '' },
            Tags: (m.Tags && typeof m.Tags === 'object') ? m.Tags : {},
            SupportedGameVersions: Array.isArray(m.SupportedGameVersions) ? m.SupportedGameVersions : [],
            ReleaseUrl: m.ReleaseUrl || '',
            TargetFileNameKeyword: m.TargetFileNameKeyword || '.zip',
            MainBinaryFileName: m.MainBinaryFileName || '',
            ConfigSectionName: m.ConfigSectionName || '',
            InstallMethod: m.InstallMethod || 'DirectRelease',
            InstallScript_Base64: m.InstallScript_Base64 || '',
            Requirements: Array.isArray(m.Requirements) ? m.Requirements : [],
            Conflicts: Array.isArray(m.Conflicts) ? m.Conflicts : []
          }));
          renderAll();
          showToast(`âœ… å·²å¯¼å…¥ ${mods.length} ä¸ª Mod`);
        } catch (err) {
          alert('è§£æå¤±è´¥ï¼š' + err.message);
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function stripJsonCommentsSafe(input) {
      let output = '';
      let inString = false;
      let stringChar = '';
      let inSingleLineComment = false;
      let inMultiLineComment = false;

      for (let i = 0; i < input.length; i++) {
        const curr = input[i];
        const next = input[i + 1];

        if (inSingleLineComment) {
          // å•è¡Œæ³¨é‡Šç›´åˆ°æ¢è¡Œç»“æŸ
          if (curr === '\n') {
            inSingleLineComment = false;
            output += curr;
          }
          continue;
        }

        if (inMultiLineComment) {
          // å¤šè¡Œæ³¨é‡Šç›´åˆ° */
          if (curr === '*' && next === '/') {
            inMultiLineComment = false;
            i++; // è·³è¿‡ /
          }
          continue;
        }

        if (inString) {
          // å­—ç¬¦ä¸²å†…éƒ¨
          if (curr === '\\') {
            // è½¬ä¹‰å­—ç¬¦ï¼Œè¿å¸¦ä¸‹ä¸€ä¸ªå­—ç¬¦ä¸€å¹¶ä¿ç•™
            output += curr;
            if (i + 1 < input.length) {
              output += input[i + 1];
              i++;
            }
            continue;
          } else if (curr === stringChar) {
            inString = false;
          }
          output += curr;
          continue;
        }

        // è¿˜æ²¡è¿›å…¥å­—ç¬¦ä¸²ï¼Œä¹Ÿä¸åœ¨æ³¨é‡Šé‡Œï¼Œæ£€æŸ¥æ˜¯å¦å¼€å§‹æ³¨é‡Šæˆ–å­—ç¬¦ä¸²
        if (curr === '"' || curr === "'") {
          inString = true;
          stringChar = curr;
          output += curr;
          continue;
        }

        if (curr === '/' && next === '/') {
          inSingleLineComment = true;
          i++; // è·³è¿‡ç¬¬äºŒä¸ª /
          continue;
        }

        if (curr === '/' && next === '*') {
          inMultiLineComment = true;
          i++; // è·³è¿‡ *
          continue;
        }

        output += curr;
      }

      return output;
    }

    // ===== åŠ è½½ç¤ºä¾‹æ•°æ® =====
    function loadSample() {
      mods = [
        {
          "Id": "PactIL",
          "Name": { "en-US": "Pact Increased Lethality", "zh-CN": "åçº¦å¢å¼ºæ¨¡ç»„" },
          "Description": {
            "en-US": "Enhances the lethality of Warsaw Pact vehicles by improving ammunition penetration values, armor modeling, and fire control systems.",
            "zh-CN": "é€šè¿‡æ”¹è¿›å¼¹è¯ç©¿é€å€¼ã€è£…ç”²å»ºæ¨¡å’Œç«æ§ç³»ç»Ÿï¼Œå¢å¼ºåçº¦é˜µè¥è½½å…·çš„æ€ä¼¤åŠ›ã€‚"
          },
          "Tags": {
            "balance": { "zh-CN": "å¹³è¡¡", "en-US": "Balance" },
            "warsaw-pact": { "zh-CN": "åçº¦", "en-US": "Warsaw Pact" }
          },
          "SupportedGameVersions": ["20260210"],
          "ReleaseUrl": "https://api.github.com/repos/thebeninator/Pact-Increased-Lethality/releases/latest",
          "TargetFileNameKeyword": ".zip",
          "MainBinaryFileName": "PactIncreasedLethality.dll",
          "ConfigSectionName": "PactIncreasedLethality",
          "InstallMethod": "DirectRelease"
        },
        {
          "Id": "M1A1",
          "Name": { "en-US": "M1A1 Abrams", "zh-CN": "M1A1è‰¾å¸ƒæ‹‰å§†æ–¯" },
          "Description": {
            "en-US": "Adds the M1A1 Abrams main battle tank to GHPC.",
            "zh-CN": "å°†M1A1è‰¾å¸ƒæ‹‰å§†æ–¯ä¸»æˆ˜å¦å…‹åŠ å…¥æ¸¸æˆã€‚"
          },
          "Tags": {
            "vehicle": { "zh-CN": "è½½å…·", "en-US": "Vehicle" },
            "nato": { "zh-CN": "åŒ—çº¦", "en-US": "NATO" }
          },
          "SupportedGameVersions": ["20260210"],
          "ReleaseUrl": "https://api.github.com/repos/thebeninator/M1A1Abrams/releases/latest",
          "TargetFileNameKeyword": ".zip",
          "MainBinaryFileName": "M1A1Abrams.dll",
          "ConfigSectionName": "M1A1Config",
          "InstallMethod": "DirectRelease"
        },
        {
          "Id": "sample-scripted-mod",
          "Name": { "en-US": "Sample Scripted Mod", "zh-CN": "ç¤ºä¾‹è„šæœ¬MOD" },
          "Description": {
            "en-US": "A sample mod demonstrating the Scripted install method.",
            "zh-CN": "æ¼”ç¤ºè„šæœ¬å®‰è£…æ–¹å¼çš„ç¤ºä¾‹MODã€‚"
          },
          "Tags": { "sample": { "zh-CN": "ç¤ºä¾‹", "en-US": "Sample" } },
          "SupportedGameVersions": ["20260210"],
          "ReleaseUrl": "https://api.github.com/repos/REPO-OWNER/REPO/releases/latest",
          "TargetFileNameKeyword": ".dll",
          "MainBinaryFileName": "sample.dll",
          "ConfigSectionName": "SampleMod",
          "InstallMethod": "Scripted",
          "InstallScript_Base64": "QGVjaG8gb2ZmClJFTSBQYXJhbWV0ZXJzOiAlMSA9IERvd25sb2FkZWQgZmlsZSBwYXRoLCAlMiA9IEdhbWUgcm9vdCBkaXJlY3RvcnksICUzID0gVGFyZ2V0IGZpbGVuYW1lCgpzZXQgIkRPV05MT0FEX0ZJTEU9JX4xIgpzZXQgIkdBTUVfUk9PVD0lfjIiCnNldCAiVEFSR0VUX0ZJTEU9JX4zIgpzZXQgIk1PRFNfRElSPSVHQU1FX1JPT1QlXE1vZHMiCgppZiBub3QgZXhpc3QgIiVET1dOTE9BRF9GSUxFJSIgKAogICAgZWNobyBFUlJPUjogRG93bmxvYWRlZCBmaWxlIG5vdCBmb3VuZDogJURPV05MT0FEX0ZJTEUlCiAgICBleGl0IC9iIDEKKQoKaWYgbm90IGV4aXN0ICIlTU9EU19ESVIlIiBta2RpciAiJU1PRFNfRElSJSIKCmZvciAlJUYgaW4gKCIlRE9XTkxPQURfRklMRSUiKSBkbyBzZXQgIkZJTEVfRVhUPSUlfnhGIgoKaWYgL2kgIiVGSUxFX0VYVCUiPT0iLmRsbCIgKAogICAgZWNobyBJbnN0YWxsaW5nIERMTDogJVRBUkdFVF9GSUxFJQogICAgY29weSAiJURPV05MT0FEX0ZJTEUlIiAiJU1PRFNfRElSJVwlVEFSR0VUX0ZJTEUlIgopIGVsc2UgaWYgL2kgIiVGSUxFX0VYVCUiPT0iLnppcCIgKAogICAgZWNobyBFeHRyYWN0aW5nIFpJUCB0byBNb2RzIGRpcmVjdG9yeQogICAgcG93ZXJzaGVsbCAtQ29tbWFuZCAiRXhwYW5kLUFyY2hpdmUgLVBhdGggJyVET1dOTE9BRF9GSUxFJScgLURlc3RpbmF0aW9uUGF0aCAnJU1PRFNfRElSJScgLUZvcmNlIgopIGVsc2UgKAogICAgZWNobyBJbnN0YWxsaW5nIGZpbGU6ICVUQVJHRVRfRklMRSUKICAgIGNvcHkgIiVET1dOTE9BRF9GSUxFJSIgIiVNT0RTX0RJUiVcJVRBUkdFVF9GSUxFJSIKKQoKZWNobyBJbnN0YWxsYXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseQo=",
          "Conflicts": [],
          "Requirements": []
        },
        {
          "Id": "SomeComplexMod",
          "Name": { "en-US": "Complex Mod", "zh-CN": "å¤æ‚MOD" },
          "Description": {
            "en-US": "A complex mod that depends on BaseMod and CoreLibrary.",
            "zh-CN": "ä¾èµ–BaseModå’ŒCoreLibraryçš„å¤æ‚MODã€‚"
          },
          "Tags": { "sample": { "zh-CN": "ç¤ºä¾‹", "en-US": "Sample" } },
          "SupportedGameVersions": ["0.24.0", "0.24.1"],
          "ReleaseUrl": "https://api.github.com/repos/example/ComplexMod/releases/latest",
          "TargetFileNameKeyword": ".zip",
          "MainBinaryFileName": "ComplexMod.dll",
          "ConfigSectionName": "ComplexModConfig",
          "InstallMethod": "DirectRelease",
          "Requirements": ["BaseMod", "CoreLibrary"],
          "Conflicts": ["IncompatibleMod1", "IncompatibleMod2"]
        }
      ];
      renderAll();
      showToast('ğŸ“‹ ç¤ºä¾‹æ•°æ®å·²åŠ è½½');
    }

    // ===== åŒå‘å†²çªæ£€æµ‹ =====
    function checkConflicts() {
      const modDict = {};
      mods.forEach(m => modDict[m.Id] = m);

      const conflictPairs = new Set();
      const issues = [];
      const fixes = [];

      // æ”¶é›†æ‰€æœ‰å†²çªå…³ç³»
      mods.forEach(mod => {
        if (mod.Conflicts) {
          mod.Conflicts.forEach(cid => {
            if (!modDict[cid]) {
              issues.push(`âš ï¸ ${mod.Id} å†²çªäº†ä¸å­˜åœ¨çš„MOD: ${cid}`);
            } else {
              conflictPairs.add(`${mod.Id}|${cid}`);
            }
          });
        }
      });

      // åŒå‘æ£€æµ‹å¹¶è‡ªåŠ¨ä¿®å¤
      conflictPairs.forEach(pair => {
        const [a, b] = pair.split('|');
        if (!conflictPairs.has(`${b}|${a}`)) {
          issues.push(`âŒ ${a} å†²çª ${b}ï¼Œä½† ${b} æœªæ ‡è®°å†²çª ${a}`);
          if (!modDict[b].Conflicts) modDict[b].Conflicts = [];
          if (!modDict[b].Conflicts.includes(a)) {
            modDict[b].Conflicts.push(a);
            fixes.push(`âœ… å·²åœ¨ ${b} çš„ Conflicts ä¸­æ·»åŠ  ${a}`);
          }
        }
      });

      // æ˜¾ç¤ºè¯¦ç»†æŠ¥å‘Š
      let report = '=== å†²çªæ£€æŸ¥æŠ¥å‘Š ===\n\n';

      if (issues.length === 0) {
        report += 'âœ… æœªå‘ç°å†²çªé—®é¢˜ï¼æ‰€æœ‰å†²çªå…³ç³»éƒ½æ˜¯åŒå‘çš„ã€‚';
        alert(report);
        showToast('âœ… æœªå‘ç°å†²çªé—®é¢˜');
        return;
      }

      report += `å‘ç° ${issues.length} ä¸ªé—®é¢˜ï¼š\n\n`;
      issues.forEach(issue => report += issue + '\n');

      if (fixes.length > 0) {
        report += `\nå·²è‡ªåŠ¨ä¿®å¤ ${fixes.length} ä¸ªé—®é¢˜ï¼š\n\n`;
        fixes.forEach(fix => report += fix + '\n');
        report += '\næç¤ºï¼šä¿®æ”¹å·²åº”ç”¨ï¼Œè¯·å¯¼å‡ºä¿å­˜ã€‚';
      }

      alert(report);
      showToast(`ğŸ” å‘ç° ${issues.length} ä¸ªé—®é¢˜ï¼Œå·²ä¿®å¤ ${fixes.length} ä¸ª`);
      console.log('å†²çªæ£€æŸ¥è¯¦ç»†æŠ¥å‘Šï¼š', { issues, fixes });

      if (fixes.length > 0) renderAll();
    }

    // ===== å·¥å…·å‡½æ•° =====
    function esc(str) {
      return (str || '').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2500);
    }

    // Base64 ç¼–ç /è§£ç 
    function base64Encode(str) {
      return btoa(unescape(encodeURIComponent(str)));
    }

    function base64Decode(str) {
      try {
        return decodeURIComponent(escape(atob(str)));
      } catch (e) {
        return '';
      }
    }

    // åˆ‡æ¢è„šæœ¬ç¼–è¾‘æ¨¡å¼
    function toggleScriptMode(index) {
      const textarea = document.getElementById(`script-${index}`);
      const btn = document.getElementById(`script-btn-${index}`);
      const isBase64 = btn.dataset.mode === 'base64';

      if (isBase64) {
        // åˆ‡æ¢åˆ°æºç æ¨¡å¼
        textarea.value = base64Decode(mods[index].InstallScript_Base64);
        btn.textContent = 'ğŸ’¾ ä¿å­˜ä¸º Base64';
        btn.dataset.mode = 'source';
      } else {
        // åˆ‡æ¢åˆ° Base64 æ¨¡å¼
        mods[index].InstallScript_Base64 = base64Encode(textarea.value);
        textarea.value = mods[index].InstallScript_Base64;
        btn.textContent = 'ğŸ“ ç¼–è¾‘æºç ';
        btn.dataset.mode = 'base64';
        updatePreview();
      }
    }

    // ===== å¯åŠ¨ =====
    init();
  </script>
</body>

</html>